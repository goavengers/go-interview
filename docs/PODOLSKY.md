## Вопросы от Данила Подольского на позицию Senior Golang Backend Developer в компанию Evrone

### 1. Go — императивный или декларативный? А в чем разница?

В основном Императивный.
Разница в подходе:
- императивный - как сделать (прямо пошагово);
- декларативный - что сделать (итоговый результат).

### 2. Что такое type switch?

Сравнение  типов переменной, а не ее значений.

### 3. Как сообщить компилятору, что наш тип реализует интерфейс?

Если наш тип реализует все методы интерфейса, значит он реализует этот интерфейс.

### 4. Как работает append?

Если capacity исходного массива достаточно, он используется повторно. В противном случае выделяется новый базовый массив достаточной длины и данные копируются

### 5. Какое у slice zero value? Какие операции над ним возможны?

Zero value у slice == nil
Возможные операции: len, cap, append.

### 6. Как устроен тип map?

Map в Go это хэш таблица, позволяющая хранить пары ключ-значение и обладающая следующими функциями: маппинг, вставка, удаление, поиск. Map in Go не упорядоченная. Место поиска определяется рандомно. Когда мы пытаемся получить значение из мапы, а его там нет, получаем «нулевое значение типа», что в случае числа 0. Map — ссылочный тип и мало объявить переменную, надо ее проинициализировать.

### 7. Каков порядок перебора map?

Случайным образом.

### 8. Что будет, если читать из закрытого канала?

Вернется нулевое значение.

### 9. Что будет, если писать в закрытый канал?

Произойдет вызов panic.

### 10. Как вы отсортируете массив структур по алфавиту по полю Name?

С помощью функции sort.SliceStable. Для этого сначала конвертируем массив в слайс.
```go
slice := array[:]
```

### 11. Что такое сериализация? Зачем она нужна?

Сериализация — это преобразование объекта в какой-либо формат с тем, чтобы потом можно было восстановить из этого формата. Допустим, после передачи как набора байт по сети. Или сохранения в файл на диск.

### 12. Сколько времени в минутах займет у вас написание процедуры обращения односвязного списка?

Тут каждый считает сам. Попробуйте с таймингом (засеките время).

### 13. Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?

Небольшое копирование лучше, чем небольшая зависимость. Даже в стандартной библиотеке есть места, где те же io.Reader или fmt.Stringer переопределены, чтобы избежать ненужной зависимости от других пакетов. Если интерфейс маленький, скопировать его не составит труда, а если он большой, то есть вероятность, что в будущем одному модулю понадобятся одни методы, а другому - другие.

### 14. Предположим, ваша функция должна возвращать детализированные Recoverable и Fatal ошибки. Как это реализовано в пакете net? Как это надо делать в современном Go?

[Обработка ошибок в Go 1.13](https://habr.com/ru/company/vk/blog/473658/). Вкратце: Go обрабатывает ошибки как значения. В версии 1.13 добавлены метод Unwrap, исследование ошибок с помощью Is и As, упаковка ошибок с помощью %w для fmt.Errorf.

### 15. Главный недостаток стандартного логгера?

Стандартными логгерами являются: log и log/syslog. Однако в них не реализована идея разделения сообщений по уровням важности (информационные, ошибки, отладочная информация, различные дампы) и сопутствующие плюшки (цвет сообщений и т.д.). Такими пакетами являются: logrus, glog.

### 16. Есть ли для Go хороший orm? Ответ обоснуйте.

Для работы с базами данных можно использовать пакет database/sql. Но есть куча ORM, можно выбрать любую. Все зависит от исходной посылки.

### 17. Какой у вас любимый линтер?

Go vet + golint

### 18. Можно ли использовать один и тот же буфер []byte в нескольких горутинах?

Зачем может понадобиться использовать один и тот же буфер []byte в нескольких горутинах параллельно? Не за чем, для этого существуют каналы. Но даже если такая задача стоит, то в этом случае - это общие данные и тут необходимо исключить возможность одновременного выполнения нескольких операций записи. Например используя мьютексы. 

### 19. Какие типы мьютексов предоставляет stdlib?

В стандартной библиотеке есть пакет sync. Он предоставляет следующие типы мьютексов:
- sync.Mutex - блокирует и снимает блокировку;
- sync.RWMutex - тоже самое, но есть отдельно блокировка на чтение/запись и отдельно на чтение;
- отдельно стоит упомянуть sync.Map - вид мьютекса для мап.

### 20. Что такое lock-free структуры данных, и есть ли в Go такие?

Синхронизация – это узкое место параллельных программ. Распараллеливая алгоритмы, мы работаем с последовательными структурами данных, обеспечивая их работу примитивами синхронизации – критическими секциями, мьютексами, условными переменными (condvar); в результате мы выстраиваем все наши потоки в очередь на доступ к структуре данных, тем самым убивая параллельность.

В академической среде изучение способов реализации конкурентных структур данных, обеспечивающих одновременный доступ к разделяемым данным, привело к созданию нескольких основных направлений:
- Lock-free структуры данных;
- Fine-grained algorithms;
- Транзакционная память (transactional memory).

Lock-free структуры данных - не требующие внешней синхронизации доступа. Это неформальное, чисто техническое определение, отражающее внутреннее строение контейнера и операций над ним. 
Формальное определение lock-free объекта звучит так: разделяемый объект называется lock-free объектом (неблокируемым, non-blocking объектом), если он гарантирует, что некоторый поток закончит выполнение операции над объектом за конечное число шагов вне зависимости от результата работы других потоков (даже если эти другие потоки завершились крахом).

В Go есть sync.Map и пакет atomic. Но с точки зрения указанных определений, а также реализации данных пакетов - это не чистый lock-free, это просто абстрактная реализация этой модели.

### 21. Способы поиска проблем производительности на проде?

Анализ метрик (Prometheus и Grafana), кода (pprof) - это про продукт. Анализ загрузки сети (интерфейсы маршрутизаторов, МСЭ и т.д.), соединений (tshark, wireshark) - это про сеть. И железо - логи ОС и т.д.

### 22. Стандартный набор метрик prometheus в Go-программе?


### 23. Как встроить стандартный профайлер в свое приложение?


### 24. Overhead от стандартного профайлера?


### 25. Почему встраивание — не наследование?

Буква L в аббревиатуре SOLID обозначает Liskov Substitution - объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы. Этот принцип предложила [Барбара Лисков](https://en.wikipedia.org/wiki/Barbara_Liskov). 

При использовании наследования объект представляет собой наследуемый тип, тем самым наследуя функциональность, которой делятся родители. При использовании композиции у объекта есть все признаки, что предоставляют необходимую для объекта функциональность. Другой объект может повторно использовать некоторые из данных функциональностей, однако тип родителя или иерархия, восходящая к нему, отсутствует.

### 26. Какие средства обобщенного программирования есть в Go?

Обобщенное программирование — это форма, в которой мы подключаем шаблоны, известные как дженерики, которые на самом деле не являются истинным исходным кодом, но компилируются компилятором для преобразования их в исходный код. [Дженерики будут](https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md) с версии 1.18.

### 27. Какие технологические преимущества языка Go вы можете назвать?

- Параллелизм
- Кроссплатформенность
- Скорость и компиляция
- Статическая типизация
- Богатая стандартная библиотека
- Возможность писать в функциональном стиле
- Нет ООП
- Авторитетные отцы-основатели и сильное комьюнити
- Простой и понятный синтаксис
- Open Source
- Обаятельный талисман

### 28. Какие технологические недостатки языка Go вы можете назвать?

- быстрый, да не такой как C, C++
- нет ООП
- всех бесят if err
- кто-то говорит про дженерики, но это лично его мнение